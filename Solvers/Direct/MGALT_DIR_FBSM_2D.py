# FORM: [J,plot_vars] = MGALT_DIR_FBSM_2D(member,bod,const,opts,var)
#
# |-----------------------------------------------------------------------
# | NOTES:
# |     -Cost function solver for use with MGALT STOpS
# |
# |     -This is the DIRECT segmented method for representing a low-thrust 
# |     orbital tragectory, taken from Coverstone
# |
# |-----------------------------------------------------------------------
# |
# | INPUTS:
# |     -member             (1,Nvar)    [float]         [unitless]
# |         A single member of a population input into the function
# |     -bod                (1,1)       [struct]        [unitless]
# |         A struct containing information pertaining to the planetary
# |         bodies. Contains list of bodies, launch windows and ToF, and 
# |         planetary R/V/JD vectors. This struct has dynamic fields and 
# |         will adapt to contain only the necesary information
# |     -const              (1,1)       [struct]        [unitless]
# |         A struct containing constants used in the calcs. Contains
# |         values for AU, TU, Sun (rad/mu/rp) and (rad/mu/rp/SOI/per) 
# |         for any bodies used in the optsimization scheme. This is a 
# |         dynamic struct and will adapt to contain only the necesary 
# |         information
# |     -opts                (1,1)       [struct]        [unitless]
# |         A struct containing constants user optsions. Contains the save 
# |         folder, ToF values, and more structs containing informaiton 
# |         for the island model, cost parameters, weighting parameters, 
# |         and all of the islands used in the optsimization process
# |     -var                (1,1)       [struct]        [unitless]
# |         A struct containing the variable limits
# |
# |-----------------------------------------------------------------------
# |
# | OUTPUTS:
# |     -J                  (1,1)       [float]         [unitless]
# |     	The cost of this member, denoted as 'f' in other functions
# |     -plot_vars          (1,1)       [struct]     	[unitless]
# |         An object containing a lot of information about the 
# |         optsimization parameters including: transfers(t and y ode 
# |         outputs), thrust values, thruster pointing angles, transfer 
# |         starting position, planet start/end locations for each 
# |         transfer, JD of each transfer, and tspans of each transfer
# |
# |-----------------------------------------------------------------------
# |
# | MISC:
# |     -References
# |         G. A. Rauwolf and V. L. Coverstone-Carroll, “Near-optsimal Low-Thrust Orbit Transfers Generated by a Genetic Algorithm,” Journal of Spacecraft and Rockets, vol. 33, pp. 859–862, Nov. 1996.
# |
# |-----------------------------------------------------------------------

import numpy as np
from Solvers.Transfer_Conditions.MGALT_conditionsInit import MGALT_conditionsInit
from Solvers.Direct.MGALT_DIR_FBSM_2D_EOM import MGALT_DIR_FBSM_2D_EOM
from Solvers.Transfer_Conditions.MGALT_conditionsTransFBSM import MGALT_conditionsTransFBSM
from scipy.integrate import odeint
import math
from Other_Functions.MGALT_stateBodies import MGALT_stateBodies
from Solvers.Direct.MGALT_DIR_FBSM_mass_2D_EOM import MGALT_DIR_FBSM_mass_2D_EOM
from Solvers.Transfer_Conditions.MGALT_conditionsGravityAssist import MGALT_conditionsGravityAssist
from Solvers.Transfer_Conditions.MGALT_convertHelioLVLH import MGALT_convertHelioLVLH
from Solvers.Cost_Functions.MGALT_FBSM_costFun import MGALT_FBSM_costFun
from Solvers.Direct.DIR_sepVariables import DIR_sepVariables

def MGALT_DIR_FBSM_2D(member,bod,const,opts,var):

    ## Setup
    
    # Canonical Units
    AU = const['AU'][0]                  # [km/AU]
    TU = const['TU'][0]*86400            # [sec/TU]
    mew_sun = const['Sun_mu'][0]         # [km^3/s^2]
    mew_sc = mew_sun*(TU**2/AU**3)  	# [DU^3/TU^2] Mew for the spacecraft
    
    # Total Cost
    J = 0
    
    # Other
    transfers = var['transfers']

    # ODE varaibles
    tspan_divider = 400    
    
    ## Pre-Allocation
    plot_vars = {}
    plot_vars['Y0_fs'] = np.zeros((8,transfers))
    plot_vars['Y0_bs'] = np.zeros((8,transfers))
    plot_vars['transfers_fs'] = np.zeros((tspan_divider*int(opts['thrust']['Nseg']/2),6*transfers))
    plot_vars['transfers_bs'] = np.zeros((tspan_divider*int(opts['thrust']['Nseg']/2),6*transfers))
    plot_vars['transfers'] = np.zeros((2*tspan_divider*int(opts['thrust']['Nseg']/2),6*transfers))
    plot_vars['thrust_switch_fs'] = np.zeros((1,int(opts['thrust']['Nseg']/2)*transfers))
    plot_vars['thrust_switch_bs'] = np.zeros((1,int(opts['thrust']['Nseg']/2)*transfers))
    plot_vars['thrust_phi_fs'] = np.zeros((1,int(opts['thrust']['Nseg']/2)*transfers))
    plot_vars['thrust_phi_bs'] = np.zeros((1,int(opts['thrust']['Nseg']/2)*transfers))
    plot_vars['seg_start_fs'] = np.zeros((int(opts['thrust']['Nseg']/2),5*transfers))
    plot_vars['seg_start_bs'] = np.zeros((int(opts['thrust']['Nseg']/2),5*transfers))
    
    # Orbit variables
    tspan_fs = [[] for i in range(transfers)]
    tspan_bs = [[] for i in range(transfers)]
    tspan_fs_temp = np.zeros((int(opts['thrust']['Nseg']/2),tspan_divider))
    tspan_bs_temp = 1*tspan_fs_temp
    JD = np.zeros((transfers,2))
    
    thrust_fs = np.zeros((transfers,int(opts['thrust']['Nseg']/2)))
    phi_fs = np.zeros((transfers,int(opts['thrust']['Nseg']/2)))
    thrust_bs = np.zeros((transfers,int(opts['thrust']['Nseg']/2)))
    phi_bs = np.zeros((transfers,int(opts['thrust']['Nseg']/2)))
    
    
    # Cost function variables
    pos_rad_sc_fs = np.zeros((1,transfers))
    pos_rad_sc_bs = np.zeros((1,transfers))
    pos_ang_sc_fs = np.zeros((1,transfers))
    pos_ang_sc_bs = np.zeros((1,transfers))
    vel_rad_sc_fs = np.zeros((1,transfers))
    vel_rad_sc_bs = np.zeros((1,transfers))
    vel_tan_sc_fs = np.zeros((1,transfers))
    vel_tan_sc_bs = np.zeros((1,transfers))
    transfer_time_sc_fs = np.zeros((1,transfers))
    transfer_time_sc_bs = np.zeros((1,transfers))
    mass_sc_fs_end = np.zeros((1,transfers))
    mass_sc_bs_end = np.zeros((1,transfers))
    
    
    # Transfer variables
    planet_departure = np.zeros((6,1))
    planet_trans = np.zeros((6,transfers-1))
    planet_target = np.zeros((6,1))
    
    
    
    ## Perform Transfer(s)
    
    if transfers == 1:        # Going from planet A to B
         
        # JD for the bodies during transfer segments
        JD[0,:] = [member[0], member[0]+member[-1]]       # Start and end Julian Day
        
        # time steps
        tstep = ((JD[0,-1] - JD[0,0])*86400) / opts['thrust']['Nseg']
        
        # Forward Time
        t0_fs = 0                          # Initial time forward
        for i1 in range(int(opts['thrust']['Nseg']/2)):
            tspan_fs_temp[i1,:] = np.linspace(t0_fs,t0_fs+tstep,tspan_divider)
            t0_fs = t0_fs+tstep
        
        tspan_fs_temp = tspan_fs_temp/TU
        
        # Backward Time
        t0_bs = tspan_fs_temp[-1,-1]*TU  # Initial time backward
        for i2 in range(int(opts['thrust']['Nseg']/2)):
            tspan_bs_temp[i2,:] = np.linspace(t0_bs,t0_bs-tstep,tspan_divider)
            t0_bs = t0_bs-tstep
        
        tspan_bs_temp = tspan_bs_temp/TU
        
        # Get time steps
        tspan_fs = 1*tspan_fs_temp       # TU
        tspan_bs = 1*tspan_bs_temp       # TU
        
        # Get the angles
        # Using the FSM parser because single transfer has the same data
        # format
        [mem_thrust,mem_phi] = DIR_sepVariables('LT_DIR_FSM_2D',member,1,opts['thrust']['Nseg'])[1:]
        
        thrust_fs = mem_thrust[0,:int(opts['thrust']['Nseg']/2)]
        phi_fs = mem_phi[0,:int(opts['thrust']['Nseg']/2)]
        thrust_bs = mem_thrust[0,int(opts['thrust']['Nseg']/2):][::-1]
        phi_bs = mem_phi[0,int(opts['thrust']['Nseg']/2):][::-1]
        
        
        # ********** bodY CONDITIONS **********
        # Get departure body initial conditions
        [planet_R_dep,planet_V_dep,sc_dep_pos_rad,sc_dep_pos_ang,sc_dep_vel_rad,sc_dep_vel_tan] = MGALT_conditionsInit(JD[0,0],bod,const,opts,var,[0,1,2])
        
        # Get target body final conditions
        [planet_R_tar,planet_V_tar,sc_tar_pos_rad,sc_tar_pos_ang,sc_tar_vel_rad,sc_tar_vel_tan] = MGALT_conditionsInit(JD[-1,-1],bod,const,opts,var,[3,4,5])
        
        
        # ********** FORWARD SHOOTING **********
        # Check to see if any additional dV from launch vehicle
        if opts['thrust']['launch_dV_rad']:
            sc_dep_vel_rad = sc_dep_vel_rad + (opts['thrust']['launch_dV_rad']*(TU/AU))

        if opts['thrust']['launch_dV_tan']:
            sc_dep_vel_tan = sc_dep_vel_tan + (opts['thrust']['launch_dV_tan']*(TU/AU))
        
        
        # Define the state for forward shooting
        mass_fs_Y0 = opts['thrust']['m0']     # inital mass (kg)
        Y0_fs = [sc_dep_pos_rad,sc_dep_pos_ang,sc_dep_vel_rad,sc_dep_vel_tan,mass_fs_Y0]
        seg_coords_fs = np.zeros((int(opts['thrust']['Nseg']/2),len(Y0_fs)))
        seg_coords_fs[0,:] = Y0_fs
        
        # ODE45 to solve for first forward segment
        # [ttot_fs,Ytot_fs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            # tspan_fs{1,1}(1,:),Y0_fs,opts.ode,const,opts,mew_sc,thrust_fs(1),phi_fs(1))
        Ytot_fs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[0,:],args=(const,opts,mew_sc,thrust_fs[0],phi_fs[0]),rtol=1e-8)
        ttot_fs = tspan_fs[0,:][:,None]
        
        # ODE45 to solve for the rest of the forward segments
        for i3 in range(1,int(opts['thrust']['Nseg']/2)):
            Y0_fs = Ytot_fs[-1,:]
            seg_coords_fs[i3,:] = Y0_fs
            
            # [ttot_fs_temp,Ytot_fs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            #     tspan_fs{1,1}(i3,:),Y0_fs,opts.ode,const,opts,mew_sc,thrust_fs(i3),phi_fs(i3))
            Ytot_fs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[i3,:],args=(const,opts,mew_sc,thrust_fs[i3],phi_fs[i3]),rtol=1e-8)
            Ytot_fs = np.vstack((Ytot_fs,Ytot_fs_temp))
            ttot_fs = np.vstack((ttot_fs, tspan_fs[i3,:][:,None]))
        
        
        # End Conditions        
        pos_rad_sc_fs   	= Ytot_fs[-1,0]
        pos_ang_sc_fs    	= (Ytot_fs[-1,1]/360 - math.floor(Ytot_fs[-1,1]/360))*360   # Accounts for being larger than 360
        vel_rad_sc_fs   	= Ytot_fs[-1,2]
        vel_tan_sc_fs       = Ytot_fs[-1,3]
        transfer_time_sc_fs	= ttot_fs[-1]
        
        # ********** BACKWARDS SHOOTING **********
        # Get the mass for the start of backwards shooting
        d_mass = np.zeros(len(tspan_bs[0,:]))
        d_mass[-1] = Ytot_fs[-1,-1]      # Mass after first patch point
        for i4 in range(int(opts['thrust']['Nseg']/2)):
            # For future work, sc_tar_pos_rad is the radial position. This
            # only comes into play if 'SolarSail_thrust' is being used as
            # the thrust model because it needs to know how far away it is.
            # This is something which will need to be assumed and the EOM's
            # will need to be added. This should be as simple as taking the
            # position of the planet and proping forward.

            d_mass = odeint(MGALT_DIR_FBSM_mass_2D_EOM,d_mass[-1],tspan_bs[i4,:],args=(const,opts,sc_tar_pos_rad,thrust_bs[i4]),rtol=1e-8)

        mass_bs_Y0 = d_mass[-1]
        
        # Define the state for backwards shooting
        Y0_bs = [sc_tar_pos_rad,sc_tar_pos_ang,sc_tar_vel_rad,sc_tar_vel_tan,mass_bs_Y0]
        seg_coords_bs = np.zeros((int(opts['thrust']['Nseg']/2),len(Y0_bs)))
        seg_coords_bs[0,:] = Y0_bs
        
        # ODE45 to solve for first backward segment
        # [ttot_bs,Ytot_bs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
        #     tspan_bs{1,1}(1,:),Y0_bs,opts.ode,const,opts,mew_sc,thrust_bs(1),phi_bs(1))
        Ytot_bs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[0,:],args=(const,opts,mew_sc,thrust_bs[0],phi_bs[0]),rtol=1e-8)
        ttot_bs = tspan_bs[0,:][:,None]
        
        # ODE45 to solve for the rest of the backward segments
        for i5 in range(1,int(opts['thrust']['Nseg']/2)):
            Y0_bs = Ytot_bs[-1,:]
            seg_coords_bs[i5,:] = Y0_bs
            
            # [ttot_bs_temp,Ytot_bs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            #     tspan_bs{1,1}(i3,:),Y0_bs,opts.ode,const,opts,mew_sc,thrust_bs(i3),phi_bs(i3))
            Ytot_bs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[i5,:],args=(const,opts,mew_sc,thrust_bs[i5],phi_bs[i5]),rtol=1e-8)
            Ytot_bs = np.vstack((Ytot_bs,Ytot_bs_temp))
            ttot_bs = np.vstack((ttot_bs, tspan_bs[i5,:][:,None]))
        
        # End Conditions
        pos_rad_sc_bs    	= Ytot_bs[-1,0]
        pos_ang_sc_bs    	= (Ytot_bs[-1,1]/360 - math.floor(Ytot_bs[-1,1]/360))*360   # Accounts for being larger than 360
        vel_rad_sc_bs   	= Ytot_bs[-1,2]
        vel_tan_sc_bs     = Ytot_bs[-1,3]
        transfer_time_sc_bs	= ttot_bs[-1]
        
        
        # ********** Append to spacecraft plotting variables **********
        planet_departure = np.vstack((planet_R_dep[:,None],planet_V_dep[:,None]))
        planet_target = np.vstack((planet_R_tar[:,None],planet_V_tar[:,None]))
        plot_vars['transfers_fs'] = np.hstack((ttot_fs,Ytot_fs))
        plot_vars['transfers_bs'] = np.hstack((ttot_bs,Ytot_bs))
        plot_vars['transfers'] = np.vstack( (np.hstack((ttot_fs,Ytot_fs)),np.hstack((np.flipud(ttot_bs)+ttot_fs[-1],np.flipud(Ytot_bs)))))
        plot_vars['thrust_switch_fs'] = thrust_fs[None,:]    # binary vector for Tswitch
        plot_vars['thrust_switch_bs'] = thrust_bs[None,:]
        plot_vars['thrust_phi_fs'] = phi_fs[None,:]          # still defined in LVLH coords at this point
        plot_vars['thrust_phi_bs'] = phi_bs[None,:][::-1]
        plot_vars['seg_start_fs'] = seg_coords_fs    # positions coordinates of each segment start
        plot_vars['seg_start_bs'] = seg_coords_bs
        
    else:       # Going from planet A to N via B, C, D, ...
        
        # Misc
        cost_count = 0
        
        # How many segments is the transfers broken into
        seg = len(member) - (2 + ((transfers-1)*5))	# Disregarding the misc info, how many thrust/angle
        seg = seg/transfers                          	# Thrust/angler per transfer
        seg = int(seg/2)                                	# How many segments
        
        # For indexing the positions
        array_bodies = [3,4,5]
        array_member = [int(seg*2+2),int(seg*2+3)]
        
        
        # JD for the bodies during transfer segments
        start = member[0]
        tof = member[int(seg*2)+4]
        JD[0,:] = [start, start+tof]
        for i1 in range(1,transfers-1):
            start = member[int(i1*(2*seg+5))]
            tof = member[int((i1+1)*(2*seg+5)-1)]
            JD[i1,:] = [start, start+tof]
        
        start = member[int(-2-2*seg)]
        tof = member[-1]
        JD[-1,:] = [start, start+tof]

        # Time steps
        for i2 in range(transfers):
            
            tstep = ((JD[i2,-1] - JD[i2,0])*86400) / opts['thrust']['Nseg']

            # Forward Time
            t0_fs = 0                          # Initial time forward
            for i3 in range(int(opts['thrust']['Nseg']/2)):
                tspan_fs_temp[i3,:] = np.linspace(t0_fs,t0_fs+tstep,tspan_divider)
                t0_fs = t0_fs+tstep
                
            tspan_fs_temp = tspan_fs_temp/TU

            # Backward Time
            t0_bs = tspan_fs_temp[-1,-1]*TU  # Initial time backward
            for i4 in range(int(opts['thrust']['Nseg']/2)):
                tspan_bs_temp[i4,:] = np.linspace(t0_bs,t0_bs-tstep,tspan_divider)
                t0_bs = t0_bs-tstep
            
            tspan_bs_temp = tspan_bs_temp/TU

            # Get time steps
            tspan_fs[i2] = 1*tspan_fs_temp       # TU
            tspan_bs[i2] = 1*tspan_bs_temp       # TU
            
        # Get the thrust and the angles
        # Flip the backwards ones because prop backwards in time
        
        mem_thrust = np.array([member[it] for it in range(1,int(seg*2),2)])
        mem_phi = np.array([member[it] for it in range(2,int(seg*2+1),2)])
        thrust_fs[0,:] = mem_thrust[:int(opts['thrust']['Nseg']/2)]
        phi_fs[0,:] = mem_phi[:int(opts['thrust']['Nseg']/2)]
        thrust_bs[0,:] = np.flip(mem_thrust[int(opts['thrust']['Nseg']/2):])
        phi_bs[0,:] = np.flip(mem_phi[int(opts['thrust']['Nseg']/2):])
        
        for i5 in range(1,transfers-1):
            [temp,mem_thrust,mem_phi] = DIR_sepVariables('MGALT_DIR_FBSM_2D',member,i5,seg)
            thrust_fs[i5,:] = mem_thrust[0,0:int(opts['thrust']['Nseg']/2)]
            phi_fs[i5,:] = mem_phi[0,0:int(opts['thrust']['Nseg']/2)]
            thrust_bs[i5,:] = mem_thrust[0,int(opts['thrust']['Nseg']/2):]
            thrust_bs[i5,:] = np.fliplr(thrust_bs[i5,:][None,:])
            phi_bs[i5,:] = mem_phi[0,int(opts['thrust']['Nseg']/2):]
            phi_bs[i5,:] = np.fliplr(phi_bs[i5,:][None,:])
        
        mem_thrust = np.array([member[it] for it in range(-1-int(2*seg),-2,2)])
        mem_phi = np.array([member[it] for it in range(-1-int(2*seg)+1,-1,2)])
        thrust_fs[-1,:] = mem_thrust[:int(opts['thrust']['Nseg']/2)]
        phi_fs[-1,:] = mem_phi[:int(opts['thrust']['Nseg']/2)]
        thrust_bs[-1,:] = np.flip(mem_thrust[int(opts['thrust']['Nseg']/2):])
        phi_bs[-1,:] = np.flip(mem_phi[int(opts['thrust']['Nseg']/2):])   
        del mem_thrust,mem_phi
        
        ## ********** DEPARTURE -> TRANSFER 1 **********
        
        # Departure body initial conditions
        [planet_R_dep,planet_V_dep,sc_dep_pos_rad,sc_dep_pos_ang,sc_dep_vel_rad,sc_dep_vel_tan] = MGALT_conditionsInit(JD[0,0],bod,const,opts,var,[0,1,2])
        mass_fs_Y0 = opts['thrust']['m0']     # inital mass (kg)
        
        # Check to see if any additional dV from launch vehicle
        if opts['thrust']['launch_dV_rad']:
            sc_dep_vel_rad = sc_dep_vel_rad + (opts['thrust']['launch_dV_rad']*(TU/AU))

        if opts['thrust']['launch_dV_tan']:
            sc_dep_vel_tan = sc_dep_vel_tan + (opts['thrust']['launch_dV_tan']*(TU/AU))
        
        Y0_fs = [sc_dep_pos_rad,sc_dep_pos_ang,sc_dep_vel_rad,sc_dep_vel_tan,mass_fs_Y0]
        seg_coords_fs = np.zeros((int(opts['thrust']['Nseg']/2),len(Y0_fs)))
        seg_coords_fs[0,:] = Y0_fs
        
        # ODE45 to solve for first forward segment
        # [ttot_fs,Ytot_fs] = ode45(@MGALT_DIR_FBSM_2D_EOM,tspan_fs[0][0,:],Y0_fs,opts.ode,const,opts,mew_sc,thrust_fs[0,0],phi_fs[0,0])
        Ytot_fs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[0][0,:],args=(const,opts,mew_sc,thrust_fs[0,0],phi_fs[0,0]),rtol=1e-8)
        ttot_fs = tspan_fs[0][0,:][:,None]
        
        # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
        if np.isnan(Ytot_fs[-1,4]):
            J = 9999999999999999999999
            return J,plot_vars
        
        # ODE45 to solve for the rest of the forward segments
        for i6 in range(1,int(opts['thrust']['Nseg']/2)):
            Y0_fs = Ytot_fs[-1,:]
            seg_coords_fs[i6,:] = Y0_fs
            
            # [ttot_fs_temp,Ytot_fs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,tspan_fs[0,0][i6,:],Y0_fs,opts.ode,const,opts,mew_sc,thrust_fs[0,i6],phi_fs[0,i6])
            Ytot_fs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[0][i6,:],args=(const,opts,mew_sc,thrust_fs[0,i6],phi_fs[0,i6]),rtol=1e-8)
            Ytot_fs = np.vstack((Ytot_fs,Ytot_fs_temp))
            ttot_fs = np.vstack((ttot_fs, tspan_fs[0][i6,:][:,None]))
            
            # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
            if np.isnan(Ytot_fs_temp[-1,4]):
                J = 9999999999999999999999
                return J,plot_vars
        del Ytot_fs_temp
        
        # FS end Conditions
        pos_rad_sc_fs[0,cost_count]    	= Ytot_fs[-1,0]
        pos_ang_sc_fs[0,cost_count]    	= (Ytot_fs[-1,1]/360 - math.floor(Ytot_fs[-1,1]/360))*360   # Accounts for being larger than 360
        vel_rad_sc_fs[0,cost_count]   	= Ytot_fs[-1,2]
        vel_tan_sc_fs[0,cost_count]       = Ytot_fs[-1,3]
        mass_sc_fs_end[0,cost_count]      = Ytot_fs[-1,4]
        transfer_time_sc_fs[0,cost_count]	= ttot_fs[-1]
        
        
        # For the backwards shooting, we need to know what the mass of the
        # spacecraft is. Because some portions of the thrust can be on or
        # off, or variable, a constant mass loss cannot be assumed for the
        # transfer. To find what the mass is, we need to first find the
        # planet position for the first transfer body. The spacecraft is
        # assumed to leave from the center of the body. We can then take
        # this position and put it into an ode to get the mass of the s/c
        # upon arrival at the transfer body. Then this mass can be
        # propogated backwards for the patch point.
        
        # Assume leaving from the center of the planet
        loc_planet_r = MGALT_stateBodies(JD[0,1],bod,const,opts,var,array_bodies)[0]
        sc_location = loc_planet_r*(1/AU)      # DU     
               
        
        # Get the mass for the start of backwards shooting
        d_mass = np.zeros(len(tspan_bs[0][0,:]))
        d_mass[-1] = Ytot_fs[-1,-1]      # Mass after first patch point
        for i7 in range(int(opts['thrust']['Nseg']/2)):
            # For future work, sc_tar_pos_rad is the radial position. This
            # only comes into play if 'SolarSail_thrust' is being used as
            # the thrust model because it needs to know how far away it is.
            # This is something which will need to be assumed and the EOM's
            # will need to be added. This should be as simple as taking the
            # position of the planet and proping forward.

            d_mass = odeint(MGALT_DIR_FBSM_mass_2D_EOM,d_mass[-1],tspan_bs[0][i7,:],args=(const,opts,np.linalg.norm(sc_location),thrust_bs[0,i7]),rtol=1e-8)

        mass_bs_Y0 = d_mass[-1]
        
        
        # Get transfer body position and s/c positions
        [planet_R_trans,planet_V_trans,sc_trans_pos_rad,sc_trans_pos_ang,sc_trans_vel_rad,sc_trans_vel_tan,control,sc_vel_helio_enter] = MGALT_conditionsTransFBSM(JD[0,1],bod,const,opts,var,[tspan_fs[0][0,0],2*tspan_fs[0][-1,-1]],d_mass[-1][0],     thrust_fs[0,:].tolist() + thrust_bs[0,:].tolist(),member[array_member].tolist() + [opts['weighting']['control_v']],sc_dep_pos_rad,array_bodies)
        
        # Change the control numbers
        member[array_member] = control[:2]        
        # Define the state variables for backwards shooting
        Y0_bs = [sc_trans_pos_rad,sc_trans_pos_ang,sc_trans_vel_rad,sc_trans_vel_tan,mass_bs_Y0]
        seg_coords_bs = np.zeros((int(opts['thrust']['Nseg']/2),len(Y0_fs)))
        seg_coords_bs[0,:] = Y0_fs
        
        # ODE45 to solve for first backward segment
        Ytot_bs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[0][0,:],args=(const,opts,mew_sc,thrust_bs[0,0],phi_bs[0,0]),rtol=1e-8)
        ttot_bs = tspan_bs[0][0,:][:,None]
        
        # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
        if np.isnan(Ytot_bs[-1,4]):
            J = 9999999999999999999999
            return J,plot_vars
        
        # ODE45 to solve for the rest of the backward segments
        for i8 in range(1,int(opts['thrust']['Nseg']/2)):
            Y0_bs = Ytot_bs[-1,:]
            seg_coords_bs[i8,:] = Y0_bs
            
            Ytot_bs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[0][i8,:],args=(const,opts,mew_sc,thrust_bs[0,i8],phi_bs[0,i8]),rtol=1e-8)
            
            Ytot_bs = np.vstack((Ytot_bs,Ytot_bs_temp))
            ttot_bs = np.vstack((ttot_bs, tspan_bs[0][i6,:][:,None]))
            
            # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
            if np.isnan(Ytot_bs_temp[-1,4]):
                J = 9999999999999999999999
                return J,plot_vars
        del Ytot_bs_temp
        
        # BS end Conditions
        pos_rad_sc_bs[0,cost_count]    	= Ytot_bs[-1,0]
        pos_ang_sc_bs[0,cost_count]    	= (Ytot_bs[-1,1]/360 - math.floor(Ytot_bs[-1,1]/360))*360   # Accounts for being larger than 360
        vel_rad_sc_bs[0,cost_count]   	= Ytot_bs[-1,2]
        vel_tan_sc_bs[0,cost_count]       = Ytot_bs[-1,3]
        mass_sc_bs_end[0,cost_count]      = Ytot_bs[-1,4]
        transfer_time_sc_bs[0,cost_count]	= ttot_bs[-1]
        
        # Count up the array bodies
        array_bodies = [it+3 for it in array_bodies]
        array_member = [2*(int(2*seg)+5)-3,2*(int(2*seg)+5)-2]   # Have the 2 because starting 2nd transfer
        cost_count = cost_count+1
        
        
        # Append to spacecraft plotting variables
        planet_departure = np.vstack((planet_R_dep[:,None],planet_V_dep[:,None]))
        planet_trans[:,0] = np.vstack((planet_R_trans[:,None],planet_V_trans[:,None]))[:,0]
        plot_vars['transfers_fs'][:,:6] = np.hstack((ttot_fs,Ytot_fs))
        plot_vars['transfers_bs'][:,:6] = np.hstack((ttot_bs,Ytot_bs))
        plot_vars['transfers'][:,:6] = np.vstack( (np.hstack((ttot_fs,Ytot_fs)),np.hstack((np.flipud(ttot_bs)+ttot_fs[-1],np.flipud(Ytot_bs)))))
        plot_vars['thrust_switch_fs'][0,:int(opts['thrust']['Nseg']/2)] = thrust_fs[0,:]    # binary vector for Tswitch
        plot_vars['thrust_switch_bs'][0,:int(opts['thrust']['Nseg']/2)] = thrust_bs[0,:]
        plot_vars['thrust_phi_fs'][0,:int(opts['thrust']['Nseg']/2)] = phi_fs[0,:]          # still defined in LVLH coords at this point
        plot_vars['thrust_phi_bs'][0,:int(opts['thrust']['Nseg']/2)] = phi_bs[0,:][::-1]
        plot_vars['seg_start_fs'][:,:5] = seg_coords_fs    # positions coordinates of each segment start
        plot_vars['seg_start_bs'][:,:5] = seg_coords_bs
        
        
        ##  ********** TRANSFER 1 -> TRANSFER n **********
        
        for i9 in range(1,transfers-1):
            
            # Calculate the FS departure position and vel
            rp_coe = member[(i9)*((2*seg)+5)-4]        # Number between 0 and 1 for flyby altitude
            
            # Get the gravity assist conditions
            sc_vel_helio_exit = MGALT_conditionsGravityAssist(bod,const,planet_R_trans,planet_V_trans,sc_vel_helio_enter,rp_coe,i9)[0]
            
            # Convert flyby LVLH
            sc_dep_vel = MGALT_convertHelioLVLH(const,planet_R_trans,sc_vel_helio_exit)[1]
            
            # Define the state variables for forward shooting
            mass_fs_Y0 = mass_bs_Y0     # inital mass (kg)
            Y0_fs = [sc_trans_pos_rad,sc_trans_pos_ang,sc_dep_vel[0],sc_dep_vel[1],mass_fs_Y0[0]]
            seg_coords_fs[0,:] = Y0_fs
            
            # ODE45 to solve for first forward segment
            # [ttot_fs,Ytot_fs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                # tspan_fs{i9,1}(1,:),Y0_fs,opts.ode,const,opts,mew_sc,thrust_fs(i9,1),phi_fs(i9,1))
            Ytot_fs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[i9][0,:],args=(const,opts,mew_sc,thrust_fs[i9,0],phi_fs[i9,0]),rtol=1e-8)
            ttot_fs = tspan_fs[i9][0,:][:,None]
            
            # ODE45 to solve for the rest of the forward segments
            for i10 in range(1,int(opts['thrust']['Nseg']/2)):
                Y0_fs = Ytot_fs[-1,:]
                seg_coords_fs[i10,:] = Y0_fs

                # [ttot_fs_temp,Ytot_fs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                    # tspan_fs{i9,1}(i10,:),Y0_fs,opts.ode,const,opts,mew_sc,thrust_fs(i9,i10),phi_fs(i9,i10))

                # Ytot_fs = [Ytot_fs Ytot_fs_temp]
                # ttot_fs = [ttot_fs ttot_fs_temp]
                Ytot_fs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[i9][i10,:],args=(const,opts,mew_sc,thrust_fs[i9,i10],phi_fs[i9,i10]),rtol=1e-8)
                Ytot_fs = np.vstack((Ytot_fs,Ytot_fs_temp))
                ttot_fs = np.vstack((ttot_fs, tspan_fs[0][i6,:][:,None]))
            
            # FS end Conditions
            pos_rad_sc_fs[0,cost_count]    	= Ytot_fs[-1,0]
            pos_ang_sc_fs[0,cost_count]    	= (Ytot_fs[-1,1]/360 - math.floor(Ytot_fs[-1,1]/360))*360   # Accounts for being larger than 360
            vel_rad_sc_fs[0,cost_count]   	= Ytot_fs[-1,2]
            vel_tan_sc_fs[0,cost_count]       = Ytot_fs[-1,3]
            mass_sc_fs_end[0,cost_count]      = Ytot_fs[-1,4]
            transfer_time_sc_fs[0,cost_count]	= ttot_fs[-1]
            
            # For the backwards shooting, we need to know what the mass of the
            # spacecraft is. Because some portions of the thrust can be on or
            # off, or variable, a constant mass loss cannot be assumed for the
            # transfer. To find what the mass is, we need to first find the
            # planet position for the first transfer body. The spacecraft is
            # assumed to leave from the center of the body. We can then take
            # this position and put it into an ode to get the mass of the s/c
            # upon arrival at the transfer body. Then this mass can be
            # propogated backwards for the patch point.

            # Assume leaving from the center of the planet
            loc_planet_r = MGALT_stateBodies(JD[i9,1],bod,const,opts,var,array_bodies)[0]
            sc_location = loc_planet_r*(1/AU)      # DU  
            
            # Get the mass for the start of backwards shooting
            d_mass = np.zeros(len(tspan_bs[0][0,:]))
            d_mass[-1] = Ytot_fs[-1,-1] # Mass after first patch point
            for i11 in range(int(opts['thrust']['Nseg']/2)):
                # For future work, sc_tar_pos_rad is the radial position. This
                # only comes into play if 'SolarSail_thrust' is being used as
                # the thrust model because it needs to know how far away it is.
                # This is something which will need to be assumed and the EOM's
                # will need to be added. This should be as simple as taking the
                # position of the planet and proping forward.
                # d_mass = ode45(@MGALT_DIR_FBSM_mass_2D_EOM,tspan_bs{i9,1}(i11,:),d_mass(end),opts.ode,const,opts,norm(sc_location),thrust_bs(i9,i11))
                d_mass = odeint(MGALT_DIR_FBSM_mass_2D_EOM,d_mass[-1],tspan_bs[i9][i11,:],args=(const,opts,np.linalg.norm(sc_location),thrust_bs[i9,i11]),rtol=1e-8)

            
            mass_bs_Y0 = d_mass[-1]

            # Get transfer body position and s/c positions
            [planet_R_trans,planet_V_trans,sc_trans_pos_rad,sc_trans_pos_ang,sc_trans_vel_rad,sc_trans_vel_tan,control,sc_vel_helio_enter] = MGALT_conditionsTransFBSM(JD[i9,1],bod,const,opts,var,[tspan_fs[i9][0,0],2*tspan_fs[i9][-1,-1]],d_mass[-1,0],[thrust_fs[i9,:],thrust_bs[i9,:]],member[array_member].tolist() + [opts['weighting']['control_v']],sc_trans_pos_rad,array_bodies)            

            
            # Change the control numbers
            member[array_member] = control[:2]

            # Define the state varaibles for backwards shooting
            Y0_bs = [sc_trans_pos_rad,sc_trans_pos_ang,sc_trans_vel_rad,sc_trans_vel_tan,mass_bs_Y0]
            seg_coords_bs[0,:] = Y0_bs


            # ODE45 to solve for first backward segment
            # [ttot_bs,Ytot_bs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            #     tspan_bs{i9,1}(1,:),Y0_bs,opts.ode,const,opts,mew_sc,thrust_bs(i9,1),phi_bs(i9,1))
            Ytot_bs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[i9][0,:],args=(const,opts,mew_sc,thrust_bs[i9,0],phi_bs[i9,0]),rtol=1e-8)
            ttot_bs = tspan_bs[i9][0,:][:,None]

            # ODE45 to solve for the rest of the backward segments
            for i12 in range(1,int(opts['thrust']['Nseg']/2)):
                Y0_bs = Ytot_bs[-1,:]
                seg_coords_bs[i12,:] = Y0_bs
                
                # [ttot_bs_temp,Ytot_bs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                #     tspan_bs{i9,1}(i12,:),Y0_bs,opts.ode,const,opts,mew_sc,thrust_bs(i9,i12),phi_bs(i9,i12))
                
                Ytot_bs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[i9][i12,:],args=(const,opts,mew_sc,thrust_bs[i9,i12],phi_bs[i9,i12]),rtol=1e-8)
                
                Ytot_bs = np.vstack((Ytot_bs,Ytot_bs_temp))
                ttot_bs = np.vstack((ttot_bs, tspan_bs[i9][i12,:][:,None]))

            # BS end Conditions
            pos_rad_sc_bs[0,cost_count]    	= Ytot_bs[-1,0]
            pos_ang_sc_bs[0,cost_count]    	= (Ytot_bs[-1,1]/360 - math.floor(Ytot_bs[-1,1]/360))*360   # Accounts for being larger than 360
            vel_rad_sc_bs[0,cost_count]   	= Ytot_bs[-1,2]
            vel_tan_sc_bs[0,cost_count]       = Ytot_bs[-1,3]
            mass_sc_bs_end[0,cost_count]      = Ytot_bs[-1,4]
            transfer_time_sc_bs[0,cost_count]	= ttot_bs[-1]

            # Count up the array bodies
            array_bodies = [it+3 for it in array_bodies]
            array_member = [(i9+2)*((2*seg)+5)-3,(i9+2)*((2*seg)+5)-2]   # Have the 2 because starting 2nd transfer
            cost_count = cost_count+1
            
            
            # Append to spacecraft plotting variables
            # planet_trans(:,i9) = [planet_R_transplanet_V_trans]
            # plot_vars.transfers_fs{i9,1} = [ttot_fs,Ytot_fs]
            # plot_vars.transfers_bs{i9,1} = [ttot_bs,Ytot_bs]
            # plot_vars.transfers{i9,1} = [ttot_fs,Ytot_fs...
            #                             flipud(ttot_bs)+ttot_fs(end),flipud(Ytot_bs)]
            # plot_vars.thrust_switch_fs{i9,1} = thrust_fs(i9,:)    # binary vector for Tswitch
            # plot_vars.thrust_switch_bs{i9,1} = thrust_bs(i9,:)
            # plot_vars.thrust_phi_fs{i9,1} = phi_fs(i9,:)          # still defined in LVLH coords at this point
            # plot_vars.thrust_phi_bs{i9,1} = phi_bs(i9,:)
            # plot_vars.seg_start_fs{i9,1} = seg_coords_fs    # positions coordinates of each segment start
            # plot_vars.seg_start_bs{i9,1} = seg_coords_bs
            
            planet_trans[:,i9] = np.vstack((planet_R_trans[:,None],planet_V_trans[:,None]))[:,0]
            plot_vars['transfers_fs'][:,i9*6:(i9+1)*6] = np.hstack((ttot_fs,Ytot_fs))
            plot_vars['transfers_bs'][:,i9*6:(i9+1)*6] = np.hstack((ttot_bs,Ytot_bs))
            plot_vars['transfers'][:,i9*6:(i9+1)*6] = np.vstack( (np.hstack((ttot_fs,Ytot_fs)),np.hstack((np.flipud(ttot_bs)+ttot_fs[-1],np.flipud(Ytot_bs)))))
            plot_vars['thrust_switch_fs'][0,int(i9*opts['thrust']['Nseg']/2):int((i9+1)*opts['thrust']['Nseg']/2)] = thrust_fs[i9,:]    # binary vector for Tswitch
            plot_vars['thrust_switch_bs'][0,int(i9*opts['thrust']['Nseg']/2):int((i9+1)*opts['thrust']['Nseg']/2)] = thrust_bs[i9,:]
            plot_vars['thrust_phi_fs'][0,int(i9*opts['thrust']['Nseg']/2):int((i9+1)*opts['thrust']['Nseg']/2)] = phi_fs[i9,:]          # still defined in LVLH coords at this point
            plot_vars['thrust_phi_bs'][0,int(i9*opts['thrust']['Nseg']/2):int((i9+1)*opts['thrust']['Nseg']/2)] = phi_bs[i9,:][::-1]
            plot_vars['seg_start_fs'][:,i9*5:(i9+1)*5] = seg_coords_fs    # positions coordinates of each segment start
            plot_vars['seg_start_bs'][:,i9*5:(i9+1)*5] = seg_coords_bs
        
        ## ********** TRANSFER n -> TARGET **********
        
        # Calculate the FS departure position and vel
        rp_coe = member[-6-int(2*seg)]        # Number between 0 and 1 for flyby altitude
        
        # Get the gravity assist conditions
        [sc_vel_helio_exit,temp] = MGALT_conditionsGravityAssist(bod,const,planet_R_trans,planet_V_trans,sc_vel_helio_enter,rp_coe,len(bod['bodies'])-2)

        # Convert flyby LVLH
        sc_dep_vel = MGALT_convertHelioLVLH(const,planet_R_trans,sc_vel_helio_exit)[1]

        # Define the state variables for forward shooting
        mass_fs_Y0 = mass_bs_Y0     # inital mass (kg)
        Y0_fs = [sc_trans_pos_rad,sc_trans_pos_ang,sc_dep_vel[0],sc_dep_vel[1],mass_fs_Y0[0]]
        seg_coords_fs[0,:] = Y0_fs

        # ODE45 to solve for first forward segment
        Ytot_fs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[-1][0,:],args=(const,opts,mew_sc,thrust_fs[-1,0],phi_fs[-1,0]),rtol=1e-8)
        ttot_fs = tspan_fs[-1][0,:][:,None]
        
        # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
        if np.isnan(Ytot_fs[-1,4]):
            J = 9999999999999999999999
            return J,plot_vars
        
        # ODE45 to solve for the rest of the forward segments
        for i13 in range(1,int(opts['thrust']['Nseg']/2)):
            Y0_fs = Ytot_fs[-1,:]
            seg_coords_fs[i13,:] = Y0_fs
            Ytot_fs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_fs,tspan_fs[-1][i13,:],args=(const,opts,mew_sc,thrust_fs[-1,i13],phi_fs[-1,i13]),rtol=1e-8)
            Ytot_fs = np.vstack((Ytot_fs,Ytot_fs_temp))
            ttot_fs = np.vstack((ttot_fs, tspan_fs[-1][i6,:][:,None]))
            
            # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
            if np.isnan(Ytot_fs_temp[-1,4]):
                J = 9999999999999999999999
                return J,plot_vars
        del Ytot_fs_temp

        # FS end Conditions
        pos_rad_sc_fs[0,cost_count]    	= Ytot_fs[-1,0]
        pos_ang_sc_fs[0,cost_count]    	= (Ytot_fs[-1,1]/360 - math.floor(Ytot_fs[-1,1]/360))*360   # Accounts for being larger than 360
        vel_rad_sc_fs[0,cost_count]   	= Ytot_fs[-1,2]
        vel_tan_sc_fs[0,cost_count]       = Ytot_fs[-1,3]
        mass_sc_fs_end[0,cost_count]      = Ytot_fs[-1,4]
        transfer_time_sc_fs[0,cost_count]	= ttot_fs[-1]
        
        
        # Get target body final conditions
        [planet_R_tar,planet_V_tar,sc_tar_pos_rad,sc_tar_pos_ang,sc_tar_vel_rad,sc_tar_vel_tan] = MGALT_conditionsInit(JD[-1,1],bod,const,opts,var,array_bodies)
        
         # Get the mass for the start of backwards shooting
        d_mass = np.zeros(len(tspan_bs[-1][0,:]))
        d_mass[-1] = Ytot_fs[-1,-1]     # Mass after first patch point
        for i14 in range(int(opts['thrust']['Nseg']/2)):
            # For future work, sc_tar_pos_rad is the radial position. This
            # only comes into play if 'SolarSail_thrust' is being used as
            # the thrust model because it needs to know how far away it is.
            # This is something which will need to be assumed and the EOM's
            # will need to be added. This should be as simple as taking the
            # position of the planet and proping forward.
            # [~,d_mass] = ode45(@MGALT_DIR_FBSM_mass_2D_EOM,tspan_bs{end,1}(i14,:),d_mass(end),opts.ode,const,opts,sc_tar_pos_rad,thrust_bs(end,i14))
            d_mass = odeint(MGALT_DIR_FBSM_mass_2D_EOM,d_mass[-1],tspan_bs[-1][i14,:],args=(const,opts,sc_tar_pos_rad,thrust_bs[-1,i7]),rtol=1e-8)

        mass_bs_Y0 = d_mass[-1][0]
        
        # Define the state for backwards shooting
        Y0_bs = [sc_tar_pos_rad,sc_tar_pos_ang,sc_tar_vel_rad,sc_tar_vel_tan,mass_bs_Y0]
        seg_coords_bs[0,:] = Y0_bs
        
        # ODE45 to solve for first backward segment
        Ytot_bs = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[-1][0,:],args=(const,opts,mew_sc,thrust_bs[-1,0],phi_bs[-1,0]),rtol=1e-8)
        ttot_bs = tspan_bs[-1][0,:][:,None]
        
        # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
        if np.isnan(Ytot_bs[-1,4]):
            J = 9999999999999999999999
            return J,plot_vars
        
        # ODE45 to solve for the rest of the backward segments
        for i15 in range(1,int(opts['thrust']['Nseg']/2)):
            Y0_bs = Ytot_bs[-1,:]
            seg_coords_bs[i15,:] = Y0_bs
            
            Ytot_bs_temp = odeint(MGALT_DIR_FBSM_2D_EOM,Y0_bs,tspan_bs[-1][i15,:],args=(const,opts,mew_sc,thrust_bs[-1,i15],phi_bs[-1,i15]),rtol=1e-8)
            
            Ytot_bs = np.vstack((Ytot_bs,Ytot_bs_temp))
            ttot_bs = np.vstack((ttot_bs, tspan_bs[-1][i6,:][:,None]))
            
            # Rarely there is a bug where Ytot_fs[-1,4] = NaN. This avoids the issue and moves onto the next population member
            if np.isnan(Ytot_bs_temp[-1,4]):
                J = 9999999999999999999999
                return J,plot_vars
        del Ytot_bs_temp
        
        # End Conditions
        pos_rad_sc_bs[0,-1]        = Ytot_bs[-1,0]
        pos_ang_sc_bs[0,-1]        = (Ytot_bs[-1,1]/360 - math.floor(Ytot_bs[-1,1]/360))*360   # Accounts for being larger than 360
        vel_rad_sc_bs[0,-1]        = Ytot_bs[-1,2]
        vel_tan_sc_bs[0,-1]        = Ytot_bs[-1,3]
        transfer_time_sc_bs[0,-1]  = ttot_bs[-1]
        
        # Append to spacecraft plotting variables
        planet_target = np.vstack((planet_R_tar[:,None],planet_V_tar[:,None]))
        plot_vars['transfers_fs'][:,-6:] = np.hstack((ttot_fs,Ytot_fs))
        plot_vars['transfers_bs'][:,-6:] = np.hstack((ttot_bs,Ytot_bs))
        plot_vars['transfers'][:,-6:] = np.vstack( (np.hstack((ttot_fs,Ytot_fs)),np.hstack((np.flipud(ttot_bs)+ttot_fs[-1],np.flipud(Ytot_bs)))))
        plot_vars['thrust_switch_fs'][0,int(-opts['thrust']['Nseg']/2):] = thrust_fs[-1,:]    # binary vector for Tswitch
        plot_vars['thrust_switch_bs'][0,int(-opts['thrust']['Nseg']/2):] = thrust_bs[-1,:]
        plot_vars['thrust_phi_fs'][0,int(-opts['thrust']['Nseg']/2):] = phi_fs[-1,:]          # still defined in LVLH coords at this point
        plot_vars['thrust_phi_bs'][0,int(-opts['thrust']['Nseg']/2):] = phi_bs[-1,:][::-1]
        plot_vars['seg_start_fs'][:,-5:] = seg_coords_fs    # positions coordinates of each segment start
        plot_vars['seg_start_bs'][:,-5:] = seg_coords_bs
    
    ## Plotting vars and Difference
    
    # Plotting variables
    plot_vars['planetary_conditions'] = np.hstack((planet_departure, planet_trans, planet_target))
    plot_vars['JD'] = JD          # variables necessary to plot the thrust vectors
    plot_vars['tspan_fs'] = tspan_fs  	# time spans for the orbits
    plot_vars['tspan_bs'] = tspan_bs
        
    ## Calculating Cost
    
    # Get the total cost function for the population member
    J,J_trans = MGALT_FBSM_costFun(J,np.hstack((pos_rad_sc_fs.T, pos_rad_sc_bs.T)),np.hstack((pos_ang_sc_fs.T, pos_ang_sc_bs.T)),np.hstack((vel_rad_sc_fs.T, vel_rad_sc_bs.T)),np.hstack((vel_tan_sc_fs.T, vel_tan_sc_bs.T)),np.hstack((transfer_time_sc_fs.T, transfer_time_sc_bs.T)),const,opts,var)

    return J,plot_vars,J_trans

